% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hatmatrix.R
\name{hatmatrix}
\alias{hatmatrix}
\title{Calculate hat matrix from model matrix and variance parameters}
\usage{
hatmatrix(
  Xf,
  Phi_inv,
  Xr = NULL,
  Sigma_inv = NULL,
  i = 1:nrow(Xf),
  j = subset,
  subset = 1:nrow(Xf)
)
}
\arguments{
\item{Xf}{\mjeqn{X_f \text{ in `Details'.}}{}
The \mjeqn{{N \times P_1}}{} model matrix for the fixed effects,
where \mjeqn{N}{} is the amount of data and \mjeqn{P_1}{} the dimension
of fixed effect coefficients. Must be full-rank.}

\item{Phi_inv}{\mjeqn{\Phi^{-1} \text{ in `Details'.}}{} The \mjeqn{N}{}-length numeric
vector with positive values
corresponding to the precision of \mjeqn{Y | X\beta}{}.}

\item{Xr}{\mjeqn{X_r \text{ in `Details'.}}{} \mjeqn{N \times P_2}{} model matrix for the random effects,
where \mjeqn{P_2}{} is the dimension of random effect coefficients.
Defaults to `NULL`.}

\item{Sigma_inv}{\mjeqn{\Sigma^{-1} \text{ in `Details'.}}{} Sigma_inv \mjeqn{P_2 \times P_2}{} precision matrix for the random
effects (\mjeqn{\Sigma^{-1}}{}). Must be positive-definite.
Defaults to `NULL`.}

\item{i}{Integer vector. Selects rows of \mjeqn{W}{} to output.
Entries must be between \mjeqn{1}{} and \mjeqn{N}{}.
`thm$calc(i = 1)` is equivalent to `thm$calc()[1, , drop = F]`.
Defaults to all rows.}

\item{j}{Integer vector. Selects columns of \mjeqn{W}{} to output.
Entries must be between \mjeqn{1}{} and \mjeqn{N}{},
and are restricted to values present in `subset`. Defaults to `subset`.
`thm$calc(j = 1)` is equivalent to `thm$calc()[, 1, drop = F]`.}

\item{subset}{Integer vector or logical vector with length \mjeqn{N}{}.
Selects rows of \mjeqn{X}{} to use for calculation of \mjeqn{V}{} (see `Details'), e.g.
if in the case of training data, `subset` specifies the indices of the
training data. Defaults to all rows.}
}
\value{
Numeric matrix.
}
\description{
\loadmathjax
}
\examples{
\dontrun{
library(hatmatrix)
Xf <- model.matrix(mpg ~ disp, data = mtcars)
Xr <- model.matrix(mpg ~ -1 + factor(cyl), data = mtcars)
Sigma_inv <- diag(rep(3, ncol(Xr)))
Phi_inv <- rep(2, nrow(Xf))
hatmatrix(Xf, Phi_inv, Xr, Sigma_inv)
hatmatrix(Xf, Phi_inv, Xr, Sigma_inv, i = 1:4) # returns 4 x N matrix
hatmatrix(Xf, Phi_inv, Xr, Sigma_inv, i = 1:4, subset = 1:10) # returns 4 x 10 matrix
hatmatrix(Xf, Phi_inv, Xr, Sigma_inv, i = 1:4, subset = 1:10, j = 11) # throws an error because
hatmatrix(Xf, Phi_inv, Xr, Sigma_inv, i = 1:4, subset = 1:10, j = 5:8) # returns 4 x 4 matrix
}
}
